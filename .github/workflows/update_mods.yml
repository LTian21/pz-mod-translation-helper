name: è‡ªåŠ¨æ›´æ–°ã€å¤„ç†å¹¶ä¿å­˜Modç¿»è¯‘

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

on:
  workflow_dispatch:
    inputs:
      mod_id_override:
        description: 'å¡«å…¥Mod IDæ¥è¿›è¡Œå¼ºåˆ¶æ›´æ–°(å¯æ‰¹é‡ç²˜è´´å¤šä¸ª)'
        required : false
        type: string
  schedule:
    - cron: '0 4 * * *' # æ¯å¤©UTCæ—¶é—´å‡Œæ™¨4ç‚¹è¿è¡Œ (åŒ—äº¬æ—¶é—´ä¸­åˆ12ç‚¹)
env:
  MODS_PER_JOB: 10 # æ¯ä¸ªå¹¶è¡Œä»»åŠ¡å¤„ç†10ä¸ªMod

jobs:
  setup_jobs:
    runs-on: ubuntu-latest
    outputs:
      mods_to_download: ${{ steps.combine_lists.outputs.mods_to_download }}
      mod_groups: ${{ steps.split_list.outputs.groups }}
      manual_ids_raw: ${{ github.event.inputs.mod_id_override }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Reusable Environment
        uses: ./.github/actions/setup-environment

      - name: Setup SteamCMD
        uses: CyberAndrii/setup-steamcmd@v1

      - name: Handle Manual Trigger Override
        id: manual_check
        if: github.event.inputs.mod_id_override != ''
        run: |
          MOD_IDS_STRING='${{ github.event.inputs.mod_id_override }}'
          echo "æ‰‹åŠ¨è§¦å‘æ¨¡å¼: å‡†å¤‡å¤„ç†ä»¥ä¸‹ Mod ID: $MOD_IDS_STRING"
          CLEAN_JSON_ARRAY=$(echo "$MOD_IDS_STRING" | sed 's/[^0-9]/\ /g' | grep -oE '[0-9]+' | awk 'length == 10' | sort -u | jq -Rsc 'split("\n") | map(select(. != ""))')
          echo "è½¬æ¢åçš„JSONæ•°ç»„(å·²æ¸…ç†å¹¶å»é‡): $CLEAN_JSON_ARRAY"
          echo "mods_to_download=$CLEAN_JSON_ARRAY" >> $GITHUB_OUTPUT

      - name: Smart Check for Mod Updates (Scheduled/Default)
        id: scheduled_check
        if: github.event.inputs.mod_id_override == ''
        env:
          STEAM_API_KEY: ${{ secrets.STEAM_API_KEY }}
        run: python scripts/check_updates.py

      - name: Combine update lists
        id: combine_lists
        run: |
          MANUAL_LIST='${{ steps.manual_check.outputs.mods_to_download }}'
          SCHEDULED_LIST='${{ steps.scheduled_check.outputs.mods_to_download }}'
          if [ -n "$MANUAL_LIST" ]; then
            echo "ä½¿ç”¨æ‰‹åŠ¨è§¦å‘çš„Modåˆ—è¡¨ã€‚"
            echo "mods_to_download=$MANUAL_LIST" >> $GITHUB_OUTPUT
          else
            echo "ä½¿ç”¨è‡ªåŠ¨æ£€æŸ¥çš„Modåˆ—è¡¨ã€‚"
            echo "mods_to_download=$SCHEDULED_LIST" >> $GITHUB_OUTPUT
          fi

      - name: Split Mod List into Groups for Parallel Jobs
        if: steps.combine_lists.outputs.mods_to_download != '[]' && steps.combine_lists.outputs.mods_to_download != ''
        id: split_list
        run: |
          {
            echo 'groups<<EOF'
            python scripts/split_ids.py '${{ steps.combine_lists.outputs.mods_to_download }}' ${{ env.MODS_PER_JOB }}
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"


  download_parallel:
    needs: setup_jobs
    if: needs.setup_jobs.outputs.mods_to_download != '[]' && needs.setup_jobs.outputs.mods_to_download != ''
    runs-on: ubuntu-latest
    strategy:
      matrix:
        mod_group: ${{ fromJson(needs.setup_jobs.outputs.mod_groups) }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Reusable Environment
        uses: ./.github/actions/setup-environment

      - name: Setup SteamCMD
        uses: CyberAndrii/setup-steamcmd@v1

      - name: Download Mod Group (Job ${{ strategy.job-index}})
        run: |
          MODS_JSON='${{ toJson(matrix.mod_group) }}'
          echo "æ­¤ä»»åŠ¡å°†ä¸‹è½½ä»¥ä¸‹Mod: $MODS_JSON"
          
          for MOD_ID in $(echo "$MODS_JSON" | jq -r '.[]'); do
            echo "--> [ID: $MOD_ID] æ­£åœ¨ä¸‹è½½..."
            APP_ID="108600"
            for i in {1..3}; do
              steamcmd +@sSteamCmdForcePlatformType linux +login anonymous +workshop_download_item "$APP_ID" "$MOD_ID" validate +quit && break
              echo "    ä¸‹è½½å¤±è´¥ã€‚15ç§’åé‡è¯•... (ç¬¬ $i/3 æ¬¡å°è¯•)"
              sleep 15
            done

            DOWNLOADED_MOD_PATH="${HOME}/Steam/steamapps/workshop/content/$APP_ID/$MOD_ID"
            if [ -d "$DOWNLOADED_MOD_PATH" ]; then
                DEST_PATH="temp_workshop_full/$MOD_ID"
                mkdir -p "$DEST_PATH"
                rsync -a "$DOWNLOADED_MOD_PATH/" "$DEST_PATH/"
                echo "    [ID: $MOD_ID] ä¸‹è½½å®Œæˆã€‚"
            else
                echo "    è­¦å‘Š: [ID: $MOD_ID] 3æ¬¡é‡è¯•åä¸‹è½½ä»ç„¶å¤±è´¥ã€‚"
            fi
          done

      - name: Prune and Prepare Mods for Artifact Upload
        run: |
          echo "å¼€å§‹ä¿®å‰ªå·²ä¸‹è½½çš„Modï¼Œä»…ä¿ç•™ç¿»è¯‘ç›¸å…³æ–‡ä»¶..."
          mkdir -p pruned_mods
          find ./temp_workshop_full -mindepth 1 -maxdepth 1 -type d | while read MOD_DIR; do
            STAGING_DIR="pruned_mods/$(basename "$MOD_DIR")"
            mkdir -p "$STAGING_DIR"
            # ä½¿ç”¨ä¸åŸæµç¨‹å®Œå…¨ç›¸åŒçš„rsyncé€»è¾‘æ¥ç²¾ç¡®æå–æ–‡ä»¶
            rsync -a --prune-empty-dirs \
              --include='*/' \
              --include='**/media/scripts/***' \
              --include='**/media/lua/shared/Translate/***' \
              --exclude='*' \
              "$MOD_DIR/" "$STAGING_DIR/"
          done
          echo "Modä¿®å‰ªå®Œæˆã€‚"

      - name: Compress Pruned Mods
        run: |
          echo "æ­£åœ¨å°†ä¿®å‰ªåçš„æ–‡ä»¶å‹ç¼©ä¸º tar.gz ..."
          tar -czf pruned-mods-${{ strategy.job-index }}.tar.gz -C pruned_mods/ .
          echo "å‹ç¼©å®Œæˆã€‚"

      - name: Upload Pruned and Compressed Mod Group Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pruned-mods-${{ strategy.job-index }}
          path: pruned-mods-${{ strategy.job-index }}.tar.gz
          retention-days: 1

  process_and_commit:
    needs: [setup_jobs, download_parallel]
    if: needs.setup_jobs.outputs.mods_to_download != '[]' && needs.setup_jobs.outputs.mods_to_download != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Reusable Environment
        uses: ./.github/actions/setup-environment
          
      - name: Download all Pruned Mod Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: pruned-mods-*
          path: temp_artifacts/
          merge-multiple: false

      - name: Decompress and Merge Mods for Processing
        run: |
          echo "è§£å‹å¹¶åˆå¹¶æ‰€æœ‰ä¸‹è½½çš„Modå‹ç¼©åŒ…..."
          rm -rf ./data/workshop_content
          mkdir -p ./data/workshop_content
          # å¾ªç¯è§£å‹æ‰€æœ‰ä¸‹è½½çš„tar.gzæ–‡ä»¶åˆ°ç›®æ ‡ç›®å½•
          for archive in temp_artifacts/pruned-mods-*/pruned-mods-*.tar.gz; do
            if [ -f "$archive" ]; then
              tar -xzf "$archive" -C ./data/workshop_content/
            fi
          done
          echo "æ‰€æœ‰Modå‡†å¤‡å°±ç»ªã€‚"

      - name: Dynamically Add New Mod IDs to id_list.txt
        if: needs.setup_jobs.outputs.manual_ids_raw != ''
        run: |
          CLEANED_MODS_JSON='${{ needs.setup_jobs.outputs.mods_to_download }}'
          
          for ID in $(echo "$CLEANED_MODS_JSON" | jq -r '.[]'); do
            if grep -q -w -x "$ID" id_list.txt; then
              echo "  -> ID: $ID å·²å­˜åœ¨äº id_list.txt ä¸­ï¼Œæ— éœ€æ·»åŠ ã€‚"
            else
              echo "  -> ID: $ID æ˜¯æ–°IDï¼Œæ­£åœ¨æ·»åŠ åˆ° id_list.txt..."
              echo "$ID" >> id_list.txt
            fi
          done
          echo "id_list.txt æ›´æ–°å®Œæˆã€‚"

      - name: Update Timestamps After Successful Download
        env:
          STEAM_API_KEY: ${{ secrets.STEAM_API_KEY }}
        run: |
          MODS_DOWNLOADED='${{ needs.setup_jobs.outputs.mods_to_download }}'
          TIMESTAMP_FILE="data/mod_timestamps.json"
          if [ -z "$MODS_DOWNLOADED" ] || [ "$MODS_DOWNLOADED" = "[]" ]; then
            echo "æ²¡æœ‰éœ€è¦æ›´æ–°æ—¶é—´æˆ³çš„Modã€‚"
            exit 0
          fi
          
          if [ ! -f "$TIMESTAMP_FILE" ]; then echo "{}" > "$TIMESTAMP_FILE"; fi
          
          POST_DATA=$(echo "$MODS_DOWNLOADED" | jq -r 'keys[] as $i | "publishedfileids[\($i)]=\(.[$i])"' | paste -sd '&')
          ITEM_COUNT=$(echo "$MODS_DOWNLOADED" | jq 'length')
          
          echo "æ­£åœ¨å•æ¬¡APIè°ƒç”¨ä¸­è·å– $ITEM_COUNT ä¸ªModçš„è¯¦æƒ…..."
          API_RESPONSE_BATCH=$(curl --retry 5 --retry-delay 5 --retry-all-errors -s \
            -X POST "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/" \
            -d "itemcount=$ITEM_COUNT" \
            -d "$POST_DATA")
          if ! echo "$API_RESPONSE_BATCH" | jq -e '.response.publishedfiledetails' > /dev/null; then
             echo "::error::Steam APIè°ƒç”¨å¤±è´¥æˆ–è¿”å›æ— æ•ˆæ•°æ®ã€‚å“åº”å†…å®¹å¦‚ä¸‹:"
             echo "$API_RESPONSE_BATCH"
             exit 1
          fi
          echo "$API_RESPONSE_BATCH" > api_response.json
          jq -s '
            .[0] as $api_data | .[1] as $current_timestamps |
            ($api_data.response.publishedfiledetails | map({(.publishedfileid): .time_updated}) | add) as $new_timestamps |
            $current_timestamps + $new_timestamps
          ' <(echo "$API_RESPONSE_BATCH") "$TIMESTAMP_FILE" > tmp.$$.json && mv tmp.$$.json "$TIMESTAMP_FILE"
    
          echo "æ‰€æœ‰Modçš„æ—¶é—´æˆ³å·²é€šè¿‡ä¸€æ¬¡æ€§è°ƒç”¨æ›´æ–°æˆåŠŸã€‚"
 

      - name: Run Main Translation Extractor Script
        env:
          TZ: Asia/Shanghai
        run: python process_mods.py

      - name: Prepare Pull Request Body
        id: prep_pr
        run: |
          MODS_JSON='${{ needs.setup_jobs.outputs.mods_to_download }}'
          
          # æ£€æŸ¥æ˜¯å¦æœ‰éœ€è¦æ›´æ–°çš„Mod
          if [ -z "$MODS_JSON" ] || [ "$MODS_JSON" = "[]" ]; then
            echo "æ²¡æœ‰éœ€è¦æ›´æ–°çš„Modï¼Œæ— éœ€åˆ›å»ºPRã€‚"
            echo "should_create_pr=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "should_create_pr=true" >> $GITHUB_OUTPUT
          
          PR_BODY_FILE="pr_body.md"
          echo "### ğŸ¤– è‡ªåŠ¨åŒ–Modæ›´æ–°æŠ¥å‘Š" > "$PR_BODY_FILE"
          echo "" >> "$PR_BODY_FILE"
          echo "æ£€æµ‹åˆ°ä»¥ä¸‹Modæœ‰æ›´æ–°ï¼Œç›¸å…³ç¿»è¯‘æ–‡ä»¶å·²è‡ªåŠ¨ç”Ÿæˆï¼š" >> "$PR_BODY_FILE"
          echo "" >> "$PR_BODY_FILE"
          
          MOD_LIST_MARKDOWN=$(jq --argjson ids "$MODS_JSON" -r '
            (.response.publishedfiledetails | map({(.publishedfileid): .title}) | add) as $details |
            $ids[] |
            "- [**\($details[.])**](https://steamcommunity.com/sharedfiles/filedetails/?id=\(.)) (ID: `\(.)`)"
          ' api_response.json)
          echo "$MOD_LIST_MARKDOWN" >> "$PR_BODY_FILE"
          
          echo "" >> "$PR_BODY_FILE"
          echo "---" >> "$PR_BODY_FILE"
          echo "è¯·å®¡æ ¸æ–‡ä»¶å˜æ›´ï¼Œç¡®è®¤æ— è¯¯åå³å¯åˆå¹¶æ­¤æ‹‰å–è¯·æ±‚ã€‚" >> "$PR_BODY_FILE"
          echo "å·¥ä½œæµè¿è¡Œæ—¥å¿—: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> "$PR_BODY_FILE"
      
      - name: Set Today's Date
        id: set_date
        run: echo "TODAY=$(date +'%Y-%m-%d')" >> $GITHUB_ENV    

      - name: Create Pull Request
        if: steps.prep_pr.outputs.should_create_pr == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Chore(è‡ªåŠ¨åŒ–): æ›´æ–°Modå¹¶é‡æ–°ç”Ÿæˆç¿»è¯‘æ–‡ä»¶"
          branch: bot/auto-update-${{ github.run_id }}          
          title: 'ğŸ¤– è‡ªåŠ¨åŒ–Modæ›´æ–° [${{ env.TODAY }}]'
          body-path: "pr_body.md"
          
          labels: "automated-update, bot"
          reviewers: ${{ github.actor }} 

      - name: Prepare Issue Body on Failure
        if: failure()
        id: prep_issue
        env:
          WORKFLOW_NAME: ${{ github.workflow }}
          EVENT_NAME: ${{ github.event_name }}
          ACTOR_NAME: ${{ github.actor }}
          BRANCH_NAME: ${{ github.ref }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          ISSUE_BODY_FILE="issue_body.md"
          echo "### ğŸš¨ å·¥ä½œæµè¿è¡Œå¤±è´¥æŠ¥å‘Š" > "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "**å·¥ä½œæµ:** \`$WORKFLOW_NAME\`" >> "$ISSUE_BODY_FILE"
          echo "**è§¦å‘äº‹ä»¶:** \`$EVENT_NAME\`" >> "$ISSUE_BODY_FILE"
          echo "**è§¦å‘è€…:** \`$ACTOR_NAME\`" >> "$ISSUE_BODY_FILE"
          echo "**åˆ†æ”¯:** \`$BRANCH_NAME\`" >> "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "---" >> "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "#### ğŸ”´ å¤±è´¥è¯¦æƒ…" >> "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "æœ¬æ¬¡è‡ªåŠ¨åŒ–å·¥ä½œæµåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­æ„å¤–ä¸­æ–­ã€‚è¯·ç«‹å³æ£€æŸ¥ç›¸å…³çš„è¿è¡Œæ—¥å¿—ä»¥è¯Šæ–­é—®é¢˜ã€‚" >> "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "**â¡ï¸ ç‚¹å‡»æ­¤å¤„æŸ¥çœ‹è¯¦ç»†è¿è¡Œæ—¥å¿— [<sup>1</sup>]($RUN_URL)**" >> "$ISSUE_BODY_FILE"
          echo "filename=$ISSUE_BODY_FILE" >> $GITHUB_OUTPUT

      - name: Create Issue on Failure
        if: failure()
        uses: peter-evans/create-issue-from-file@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          title: "ğŸš¨ å·¥ä½œæµå¤±è´¥: è‡ªåŠ¨æ›´æ–°Modç¿»è¯‘"
          content-filepath: ${{ steps.prep_issue.outputs.filename }}
          labels: "bug, CI/CD, automated report"
          assignees: 'Laotian21'