name: 自动更新、处理并保存Mod翻译

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

on:
  workflow_dispatch:
    inputs:
      mod_id_override:
        description: '填入Mod ID来进行强制更新'
        required : false
        type: string
      full_refresh:
        description: '是否强制刷新所有Mod(id_list.txt)'
        required: false
        type: boolean
        default: false
  schedule:
    - cron: '0 4 * * *' # 每天UTC时间凌晨4点运行 (北京时间中午12点)

jobs:
  setup_jobs:
    runs-on: ubuntu-latest
    outputs:
      mods_to_download: ${{ steps.combine_lists.outputs.mods_to_download }}
      mod_groups: ${{ steps.split_list.outputs.groups }}
      manual_ids_raw: ${{ github.event.inputs.mod_id_override }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Reusable Environment
        uses: ./.github/actions/setup-environment

      - name: Setup SteamCMD
        uses: CyberAndrii/setup-steamcmd@v1

      - name: Handle Manual Trigger Override
        id: manual_check
        if: github.event.inputs.mod_id_override != ''
        run: |
          MOD_IDS_STRING='${{ github.event.inputs.mod_id_override }}'
          echo "手动触发模式: 准备处理以下 Mod ID: $MOD_IDS_STRING"
          CLEAN_JSON_ARRAY=$(echo "$MOD_IDS_STRING" | sed 's/[^0-9]/\ /g' | grep -oE '[0-9]+' | awk '/^[0-9]{8,12}$/' | sort -u | jq -Rsc 'split("\n") | map(select(. != ""))')
          echo "转换后的JSON数组(已清理并去重): $CLEAN_JSON_ARRAY"
          echo "mods_to_download=$CLEAN_JSON_ARRAY" >> $GITHUB_OUTPUT

      - name: Handle Full Refresh Trigger
        id: full_refresh_check
        if: github.event.inputs.full_refresh == 'true' && github.event.inputs.mod_id_override == ''
        run: |
          echo "强制刷新模式: 正在读取 id_list.txt 中的所有 Mod ID..."
          if [ ! -f "id_list.txt" ]; then
            echo "::error::id_list.txt 文件不存在，无法执行强制刷新。请确保文件位于仓库根目录。"
            exit 1
          fi
          ALL_MOD_IDS=$(cat id_list.txt | sed 's/[^0-9]/\ /g' | grep -oE '[0-9]+' | awk '/^[0-9]{8,12}$/' | sort -u | jq -Rsc 'split("\n") | map(select(. != ""))')
          echo "已从 id_list.txt 读取所有 Mod ID: $ALL_MOD_IDS"
          echo "mods_to_download=$ALL_MOD_IDS" >> $GITHUB_OUTPUT

      - name: Smart Check for Mod Updates (Scheduled/Default)
        id: scheduled_check
        if: github.event.inputs.mod_id_override == '' && github.event.inputs.full_refresh != 'true'
        env:
          STEAM_API_KEY: ${{ secrets.STEAM_API_KEY }}
        run: python scripts/check_updates.py

      - name: Check for Local Completion File Updates
        id: local_check
        if: github.event.inputs.mod_id_override == '' && github.event.inputs.full_refresh != 'true'
        run: |
          python scripts/check_local_changes.py > local_changes.json
          echo 'mods_to_download<<EOF' >> "$GITHUB_OUTPUT"
          cat local_changes.json >> "$GITHUB_OUTPUT"
          echo 'EOF' >> "$GITHUB_OUTPUT"

      - name: Combine update lists
        id: combine_lists
        env:
          MANUAL_LIST_INPUT: ${{ steps.manual_check.outputs.mods_to_download }}
          FULL_REFRESH_LIST_INPUT: ${{ steps.full_refresh_check.outputs.mods_to_download }}
          SCHEDULED_LIST_INPUT: ${{ steps.scheduled_check.outputs.mods_to_download }}
          LOCAL_CHANGES_LIST_INPUT: ${{ steps.local_check.outputs.mods_to_download }}

        run: |
          MANUAL_LIST="$MANUAL_LIST_INPUT"
          FULL_REFRESH_LIST="$FULL_REFRESH_LIST_INPUT"
          SCHEDULED_LIST="$SCHEDULED_LIST_INPUT"
          LOCAL_CHANGES_LIST="$LOCAL_CHANGES_LIST_INPUT"

          if [ -z "$MANUAL_LIST" ] || [ "$MANUAL_LIST" = "null" ]; then MANUAL_LIST='[]'; fi
          if [ -z "$FULL_REFRESH_LIST" ] || [ "$FULL_REFRESH_LIST" = "null" ]; then FULL_REFRESH_LIST='[]'; fi
          if [ -z "$SCHEDULED_LIST" ] || [ "$SCHEDULED_LIST" = "null" ]; then SCHEDULED_LIST='[]'; fi
          if [ -z "$LOCAL_CHANGES_LIST" ] || [ "$LOCAL_CHANGES_LIST" = "null" ]; then LOCAL_CHANGES_LIST='[]'; fi
          COMBINED_LIST='[]'
          
          if [ "$MANUAL_LIST" != "[]" ]; then
            echo "检测到手动Mod ID覆盖，将使用此列表进行处理 (优先级最高)。"
            COMBINED_LIST=$(echo "$MANUAL_LIST" | jq -c '.')
          elif [ "$FULL_REFRESH_LIST" != "[]" ]; then
            echo "检测到强制刷新模式，将使用 id_list.txt 中的所有Mod ID进行处理。"
            COMBINED_LIST=$(echo "$FULL_REFRESH_LIST" | jq -c '.')
          else
            echo "未检测到手动覆盖或强制刷新。将使用自动检查的Mod列表。"
            
            echo " - Steam更新列表: $SCHEDULED_LIST"
            echo " - 本地变更列表: $LOCAL_CHANGES_LIST"
            
            COMBINED_LIST=$(jq -n --argjson a "$SCHEDULED_LIST" --argjson b "$LOCAL_CHANGES_LIST" '($a + $b) | unique' | jq -c '.')
          fi
          
          echo "最终待处理的Mod列表: $COMBINED_LIST"
          echo "mods_to_download=$COMBINED_LIST" >> $GITHUB_OUTPUT

      - name: Calculate Mods per Job
        if: steps.combine_lists.outputs.mods_to_download != '[]' && steps.combine_lists.outputs.mods_to_download != ''
        id: job_calculator
        env:
          COMBINED_MODS_JSON: ${{ steps.combine_lists.outputs.mods_to_download }}
        run: |
          MODS_PER_JOB=$(python scripts/calculate_jobs.py "$COMBINED_MODS_JSON")
          echo "mods_per_job=$MODS_PER_JOB" >> $GITHUB_OUTPUT

      - name: Split Mod List into Groups for Parallel Jobs
        if: steps.combine_lists.outputs.mods_to_download != '[]' && steps.combine_lists.outputs.mods_to_download != ''
        id: split_list
        env:
          COMBINED_MODS_JSON: ${{ steps.combine_lists.outputs.mods_to_download }}
          MODS_PER_JOB_VAL: ${{ steps.job_calculator.outputs.mods_per_job }}
        run: |
          {
            echo 'groups<<EOF'
            python scripts/split_ids.py "$COMBINED_MODS_JSON" "$MODS_PER_JOB_VAL"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"


  download_parallel:
    needs: setup_jobs
    if: needs.setup_jobs.outputs.mods_to_download != '[]' && needs.setup_jobs.outputs.mods_to_download != ''
    runs-on: ubuntu-latest
    strategy:
      matrix:
        mod_group: ${{ fromJson(needs.setup_jobs.outputs.mod_groups) }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Reusable Environment
        uses: ./.github/actions/setup-environment

      - name: Setup SteamCMD
        uses: CyberAndrii/setup-steamcmd@v1

      - name: Download Mod Group (Job ${{ strategy.job-index}})
        env:
          MOD_GROUP_JSON: ${{ toJson(matrix.mod_group) }}
        run: |
          MODS_JSON="$MOD_GROUP_JSON"
          echo "此任务将下载以下Mod: $MODS_JSON"
          
          for MOD_ID in $(echo "$MODS_JSON" | jq -r '.[]'); do
            echo "--> [ID: $MOD_ID] 正在下载..."
            APP_ID="108600"
            for i in {1..3}; do
              steamcmd +@sSteamCmdForcePlatformType linux +login anonymous +workshop_download_item "$APP_ID" "$MOD_ID" validate +quit && break
              echo "    下载失败。15秒后重试... (第 $i/3 次尝试)"
              sleep 15
            done

            DOWNLOADED_MOD_PATH="${HOME}/Steam/steamapps/workshop/content/$APP_ID/$MOD_ID"
            if [ -d "$DOWNLOADED_MOD_PATH" ]; then
                DEST_PATH="temp_workshop_full/$MOD_ID"
                mkdir -p "$DEST_PATH"
                rsync -a "$DOWNLOADED_MOD_PATH/" "$DEST_PATH/"
                echo "    [ID: $MOD_ID] 下载完成。"
            else
                echo "    警告: [ID: $MOD_ID] 3次重试后下载仍然失败。"
            fi
          done

      - name: Prune and Prepare Mods for Artifact Upload
        run: |
          echo "开始修剪已下载的Mod，仅保留 EN/CN 相关翻译文件..."
          mkdir -p pruned_mods
          find ./temp_workshop_full -mindepth 1 -maxdepth 1 -type d | while read MOD_DIR; do
            MOD_ID=$(basename "$MOD_DIR")
            STAGING_DIR="pruned_mods/$MOD_ID"
            mkdir -p "$STAGING_DIR"
            
            rsync -a --prune-empty-dirs \
              --include='*/' \
              --include='**/media/scripts/***' \
              --include='**/[Tt]ranslate/*[Ee][Nn]*/***' \
              --include='**/[Tt]ranslate/*[Cc][Nn]*/***' \
              --exclude='**/[Tt]ranslate/*' \
              --exclude='*' \
              "$MOD_DIR/" "$STAGING_DIR/"

            if [ -n "$(find "$STAGING_DIR" -type f -print -quit)" ]; then
                echo "    [ID: $MOD_ID] Mod修剪完成，包含文件。"
            else
                echo "    警告: [ID: $MOD_ID] Mod修剪后目录为空，可能没有翻译相关文件或原始下载失败。"
            fi
          done
          echo "Mod修剪流程完成。"

      - name: Compress Pruned Mods
        run: |
          echo "正在将修剪后的文件压缩为 tar.gz ..."
          tar -czf pruned-mods-${{ strategy.job-index }}.tar.gz -C pruned_mods/ .
          echo "压缩完成。"

      - name: Upload Pruned and Compressed Mod Group Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pruned-mods-${{ strategy.job-index }}
          path: pruned-mods-${{ strategy.job-index }}.tar.gz
          retention-days: 1

  process_and_commit:
    needs: [setup_jobs, download_parallel]
    if: needs.setup_jobs.outputs.mods_to_download != '[]' && needs.setup_jobs.outputs.mods_to_download != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Reusable Environment
        uses: ./.github/actions/setup-environment
          
      - name: Download all Pruned Mod Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: pruned-mods-*
          path: temp_artifacts/
          merge-multiple: false

      - name: Prepare workshop_content for updates
        env:
          MODS_TO_DOWNLOAD_JSON_FROM_OUTPUT: ${{ needs.setup_jobs.outputs.mods_to_download }}
        run: |
          TMP_DIRS=()
          
          cleanup() {
            echo "正在执行清理操作..."
            for d in "${TMP_DIRS[@]}"; do
              if [ -d "$d" ]; then
                echo "  -> 移除临时目录: $d"
                rm -rf "$d"
              fi
            done
            echo "清理完成。"
          }
          
          trap cleanup EXIT # 确保在脚本退出时调用 cleanup 函数

          echo "准备 ./data/workshop_content 目录，合并现有内容与新下载的Mod..."
          mkdir -p ./data/workshop_content

          MODS_TO_UPDATE_JSON="$MODS_TO_DOWNLOAD_JSON_FROM_OUTPUT"

          if [ -n "$MODS_TO_UPDATE_JSON" ] && [ "$MODS_TO_UPDATE_JSON" != "[]" ] && [ "$MODS_TO_UPDATE_JSON" != "null" ]; then
            echo "正在清除本次更新Mod的旧目录..."
            for MOD_ID in $(echo "$MODS_TO_UPDATE_JSON" | jq -r '.[]'); do
              MOD_DIR="./data/workshop_content/$MOD_ID"
              if [ -d "$MOD_DIR" ]; then
                echo "  -> 移除旧版Mod目录: $MOD_DIR"
                rm -rf "$MOD_DIR"
              else
                echo "  -> 目录不存在，跳过删除: $MOD_DIR"
              fi
            done
          else
            echo "  -> 没有Mod需要更新或新增，跳过清除旧目录步骤。"
          fi

          echo "正在解压并同步更新后的Mod文件..."
          while IFS= read -r archive; do
            if [ -f "$archive" ]; then
              echo "  -> 正在处理压缩包: $(basename "$archive")"
              TMP_EXTRACT_DIR=$(mktemp -d)
              TMP_DIRS+=("$TMP_EXTRACT_DIR")
              
              if ! tar -xzf "$archive" -C "$TMP_EXTRACT_DIR"; then
                echo "  -> 警告: 解压 $archive 失败，跳过此文件。"
                continue
              fi

              for MOD_SUB_DIR in "$TMP_EXTRACT_DIR"/*; do
                if [ -d "$MOD_SUB_DIR" ]; then
                  MOD_ID=$(basename "$MOD_SUB_DIR")
                  DEST_MOD_DIR="./data/workshop_content/$MOD_ID"
                  
                  echo "    -> 同步Mod $MOD_ID 到 $DEST_MOD_DIR"
                  mkdir -p "$DEST_MOD_DIR"
                  rsync -a --delete "$MOD_SUB_DIR/" "$DEST_MOD_DIR/"
                fi
              done
            fi
          done < <(find temp_artifacts -type f -name "pruned-mods-*.tar.gz")
          echo "所有Mod内容已合并并准备就绪。"

      - name: Clean up temporary artifacts
        run: rm -rf temp_artifacts    

      - name: Dynamically Add New Mod IDs to id_list.txt
        if: needs.setup_jobs.outputs.manual_ids_raw != ''
        env:
          MODS_TO_ADD_JSON: ${{ needs.setup_jobs.outputs.mods_to_download }}
        run: |
          CLEANED_MODS_JSON="$MODS_TO_ADD_JSON"
          
          [ -n "$(tail -c1 id_list.txt)" ] && echo >> id_list.txt
          
          for ID in $(echo "$CLEANED_MODS_JSON" | jq -r '.[]'); do
            if grep -q -w -x "$ID" id_list.txt; then
              echo "  -> ID: $ID 已存在于 id_list.txt 中，无需添加。"
            else
              echo "  -> ID: $ID 是新ID，正在添加到 id_list.txt..."
              echo "$ID" >> id_list.txt
            fi
          done
          echo "id_list.txt 更新完成。"

      - name: Update Timestamps After Successful Download
        env:
          STEAM_API_KEY: ${{ secrets.STEAM_API_KEY }}
          MODS_TO_DOWNLOAD_JSON_FOR_TIMESTAMP: ${{ needs.setup_jobs.outputs.mods_to_download }}
        run: |
          MODS_DOWNLOADED="$MODS_TO_DOWNLOAD_JSON_FOR_TIMESTAMP"
          TIMESTAMP_FILE="data/mod_timestamps.json"
          if [ -z "$MODS_DOWNLOADED" ] || [ "$MODS_DOWNLOADED" = "[]" ] || [ "$MODS_DOWNLOADED" = "null" ]; then
            echo "没有需要更新时间戳的Mod。"
            exit 0
          fi
          
          if [ ! -f "$TIMESTAMP_FILE" ]; then echo "{}" > "$TIMESTAMP_FILE"; fi
          
          POST_DATA=$(echo "$MODS_DOWNLOADED" | jq -r 'to_entries[] | "publishedfileids[\(.key)]=\(.value)"' | paste -sd '&')
          ITEM_COUNT=$(echo "$MODS_DOWNLOADED" | jq 'length')
          
          echo "正在单次API调用中获取 $ITEM_COUNT 个Mod的详情..."
          API_RESPONSE_BATCH=$(curl --retry 5 --retry-delay 5 --retry-all-errors -s \
            -X POST "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/" \
            -d "itemcount=$ITEM_COUNT" \
            -d "$POST_DATA")
          if ! echo "$API_RESPONSE_BATCH" | jq -e '.response.publishedfiledetails' > /dev/null; then
             echo "::error::Steam API调用失败或返回无效数据。响应内容如下:"
             echo "$API_RESPONSE_BATCH"
             exit 1
          fi
          echo "$API_RESPONSE_BATCH" > api_response.json
          jq -s '
            .[0] as $api_data | .[1] as $current_timestamps |
            ($api_data.response.publishedfiledetails | map({(.publishedfileid): .time_updated}) | add) as $new_timestamps |
            $current_timestamps + $new_timestamps
          ' <(echo "$API_RESPONSE_BATCH") "$TIMESTAMP_FILE" > tmp.$$.json && mv tmp.$$.json "$TIMESTAMP_FILE"
    
          echo "所有Mod的时间戳已通过一次性调用更新成功。"
 

      - name: Run Main Translation Extractor Script
        env:
          TZ: Asia/Shanghai
          MODS_FOR_PYTHON: ${{ needs.setup_jobs.outputs.mods_to_download }}
        run: python process_mods.py "$MODS_FOR_PYTHON"

      - name: Prepare Pull Request Body
        id: prep_pr
        env:
          MODS_TO_DOWNLOAD_JSON_FOR_PR: ${{ needs.setup_jobs.outputs.mods_to_download }}
        run: |
          MODS_JSON="$MODS_TO_DOWNLOAD_JSON_FOR_PR"
          
          # 检查是否有需要更新的Mod
          if [ -z "$MODS_JSON" ] || [ "$MODS_JSON" = "[]" ] || [ "$MODS_JSON" = "null" ]; then
            echo "没有需要更新的Mod，无需创建PR。"
            echo "should_create_pr=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "should_create_pr=true" >> $GITHUB_OUTPUT
          
          PR_BODY_FILE="pr_body.md"
          echo "### 🤖 自动化Mod更新报告" > "$PR_BODY_FILE"
          echo "" >> "$PR_BODY_FILE"
          echo "检测到以下Mod有更新，相关翻译文件已自动生成：" >> "$PR_BODY_FILE"
          echo "" >> "$PR_BODY_FILE"
          
          MOD_LIST_MARKDOWN=$(jq --argjson ids "$MODS_JSON" -r '
            (.response.publishedfiledetails | map({(.publishedfileid): (.title // "未知Mod")}) | add) as $details |
            $ids[] |
            "- [**\($details[.])**](https://steamcommunity.com/sharedfiles/filedetails/?id=\(.)) (ID: `\(.)`)"
          ' api_response.json)
          echo "$MOD_LIST_MARKDOWN" >> "$PR_BODY_FILE"
          
          echo "" >> "$PR_BODY_FILE"
          echo "---" >> "$PR_BODY_FILE"
          echo "请审核文件变更，确认无误后即可合并此拉取请求。" >> "$PR_BODY_FILE"
          echo "工作流运行日志: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> "$PR_BODY_FILE"
      
      - name: Set Today's Date
        id: set_date
        run: echo "TODAY=$(date +'%Y-%m-%d')" >> $GITHUB_ENV    

      - name: Create Pull Request
        if: steps.prep_pr.outputs.should_create_pr == 'true'
        uses: peter-evans/create-pull-request@v6
        id: cpr
        with:
          token: ${{ secrets.AUTOMERGE_PAT }}
          commit-message: |
            Chore(自动化): 更新Mod并生成报告
            
            本次运行 (ID: ${{ github.run_id }}) 的变更包括:
            - 更新了受影响Mod的翻译文件。
            - 生成了新的状态报告 (STATUS.md, INTERNAL_STATUS.md, MOD_TODO_STATUS.md)。
            - 更新了增量日志 (data/logs/update_log.json)。
            - 存档了新的基线日志 (如果适用)。
          branch: bot/auto-update-${{ github.run_id }}
          title: '🤖 自动化Mod更新与报告 [${{ env.TODAY }}]'
          body-path: "pr_body.md"
          labels: "automated-update, bot"
          reviewers: ${{ github.actor }}

      - name: Approve the auto-generated PR
        if: steps.cpr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.cpr.outputs.pull-request-number }}
        run: |
          echo "自动批准由本工作流创建的 PR #${PR_NUMBER}..."
          gh pr review --approve "$PR_NUMBER"
          echo "批准成功。"

      - name: Enable auto-merge for the PR
        if: steps.cpr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ secrets.AUTOMERGE_PAT }}
          PR_NUMBER: ${{ steps.cpr.outputs.pull-request-number }}
        run: |
          echo "为 PR #${PR_NUMBER} 启用自动合并..."
          gh pr merge --auto --squash "$PR_NUMBER"
          echo "自动合并已成功启用。当所有检查通过后，GitHub将会自动合并此PR。"

      - name: Prepare Issue Body on Failure
        if: failure()
        id: prep_issue
        env:
          WORKFLOW_NAME: ${{ github.workflow }}
          EVENT_NAME: ${{ github.event_name }}
          ACTOR_NAME: ${{ github.actor }}
          BRANCH_NAME: ${{ github.ref }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          ISSUE_BODY_FILE="issue_body.md"
          echo "### 🚨 工作流运行失败报告" > "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "**工作流:** \`$WORKFLOW_NAME\`" >> "$ISSUE_BODY_FILE"
          echo "**触发事件:** \`$EVENT_NAME\`" >> "$ISSUE_BODY_FILE"
          echo "**触发者:** \`$ACTOR_NAME\`" >> "$ISSUE_BODY_FILE"
          echo "**分支:** \`$BRANCH_NAME\`" >> "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "---" >> "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "#### 🔴 失败详情" >> "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "本次自动化工作流在执行过程中意外中断。请立即检查相关的运行日志以诊断问题。" >> "$ISSUE_BODY_FILE"
          echo "" >> "$ISSUE_BODY_FILE"
          echo "**➡️ 点击此处查看详细运行日志 [<sup>1</sup>]($RUN_URL)**" >> "$ISSUE_BODY_FILE"
          echo "filename=$ISSUE_BODY_FILE" >> $GITHUB_OUTPUT

      - name: Create Issue on Failure
        if: failure()
        uses: peter-evans/create-issue-from-file@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          title: "🚨 工作流失败: 自动更新Mod翻译"
          content-filepath: ${{ steps.prep_issue.outputs.filename }}
          labels: "bug, CI/CD, automated report"
          assignees: 'Laotian21'
      
      - name: Trigger CI workflow From Mod Update Workflow
        uses: peter-evans/repository-dispatch@v2
        if: ${{ false && success() }}  # 该workflow会自动生成一次提交并被CI捕获，此处无需触发CI
        with:
          token: ${{ secrets.GITHUB_TOKEN }}  # 或使用 PAT，如果需要跨仓库
          event-type: trigger-ci
          client-payload: |
            {
              "source_workflow": "auto_update_mods",
              "run_id": "${{ github.run_id }}"
            }
